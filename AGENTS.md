# About the project

This project contains the code for the backend of a personal finance tracker system. The users can register their bank accounts, credit cards, incomes and expenses and track them into one single and centralized place.

## Project Overview
- **Purpose**: Personal financial control app supporting multi-user accounts, credit cards, categories/subcategories, tagged transactions, and installments.
- **Tech Stack**:  
  - **Language**: Python 3.11  
  - **Web Framework**: FastAPI (async, high performance)  
  - **ORM**: SQLModel (combines SQLAlchemy & Pydantic)  
  - **Auth**: JWT (OAuth2 Password Bearer)  
  - **DB**: PostgreSQL (via `psycopg2`)
  - **Migrations**: Alembic
  - **Package Manager**: uv

## Project Structure for files Navigation
```
app/
├── main.py                 # FastAPI app setup & router inclusion
├── core/
│   ├── config.py           # BaseSettings for env vars
│   ├── database.py         # SQLModel engine & session
│   └── security.py         # JWT & password‐hash utilities
├── models/                 # SQLModel ORM models
│   ├── user.py
│   ├── account.py
│   ├── credit\_card.py
│   ├── category.py
│   ├── transaction.py
│   └── tag.py
├── routers/                # APIRouters by resource
│   ├── auth.py
│   ├── users.py
│   ├── accounts.py
│   ├── cards.py
│   ├── categories.py
│   ├── transactions.py
│   └── tags.py
├── services/               # Business logic & CRUD operations
│   ├── auth\_service.py
│   └── finance\_service.py
├── migrations/             # Alembic files (`env.py`, `versions/`)
└── tests/                  # pytest test suites

````

## Coding Conventions
- **Language & Style**  
  - Follow **PEP 8** and **PEP 257** (docstrings in google style).  
  - Use `ruff` for formatting. 
  - Type annotations mandatory; enforce via `mypy`.
- **Naming**  
  - Modules & packages: `snake_case`.  
  - Classes: `PascalCase`.  
  - Constants: `UPPER_SNAKE_CASE`.  
  - DB tables mirror model names (e.g., `users`, `accounts`).  
- **FastAPI & SQLModel**  
  - Declare Pydantic schemas via SQLModel models or separate `schemas/` if needing fine control.  
  - Use `Depends()` for DI; keep route handlers thin.

## API Design Guidelines
- All API routes should be nested into `/api/v1` route
- **RESTful Endpoints**  
  - Resource URIs: `/users`, `/accounts/{id}`, `/transactions`, `/transactions/{id}`, etc.  
  - HTTP methods: `GET`, `POST`, `PUT`/`PATCH`, `DELETE`.  
- **Responses**  
  - Use `response_model` for validation & docs.  
  - Return proper status codes: `200`, `201`, `204`, `400`, `401`, `404`, `422`.  
- **Error Handling**  
  - Raise `HTTPException` with consistent JSON error body:  
    ```json
    { "detail": "User not found." }
    ```

## Database & Modeling Conventions
- **SQLModel Relationships**  
  - One‐to‐many: use `Relationship(back_populates=…)`.  
  - Many‐to‐many: explicit link table `TransactionTagLink`.
  - Everytime that is possible, create fields to make use of auto completion in IDE and type checking.
- **Transactions Table**  
  - Fields: `id`, `user_id`, `account_id` or `card_id`, `type`, `amount`, `occurred_at`, `charged_at`, `description`, `category_id`, `subcategory_id`, `installment_total`, `installment_number`, `group_id`.  
- **Installments**  
  - Represent each installment as its own `Transaction` record.  
  - Compute `charged_at` based on card’s `billing_day` and (optional) `closing_day`.  

## Authentication & Security
- **JWT Flow**  
  - OAuth2PasswordBearer → verify creds → issue JWT with `sub=user_id`.  
  - Short‐lived access tokens, optional refresh tokens.  
- **Password Storage**  
  - Use Bcrypt via Passlib: `pwd_context.hash()`, `pwd_context.verify()`.  
- **Route Protection**  
  - All private routes depend on `get_current_user` → inject `current_user`.  
  - Always filter queries by `current_user.id` for multi-tenancy.

## Testing Requirements
- Tests should not be implemmented yet.

## Migrations (Alembic)
Use alembic for managing database migrations.
* Initialize: `alembic init migrations`
* Configure `env.py`: import all `SQLModel` metadata.
* Generate: `alembic revision --autogenerate -m "…"`
* Apply: `alembic upgrade head`
* Review autogenerated scripts before applying.

## Pull Request Guidelines

1. Branch from `main` using `feature/...` prefix.
2. Include clear summary & issue reference in PR description.
3. Ensure all tests pass & coverage report is included.
4. Use semantic commit messages: `feat:`, `fix:`, `chore:`.
5. Request at least one review; address comments promptly.

## Commits convention
- Use conventional commits convention, such as `feat: implemment new feature`

## Programmatic Checks
Always perform linting and type checkings while coding.

```bash
# Formatting
ruff .

# Type checking
mypy .

# Migrations consistency
alembic history --verbose
```

## Package manager
- Use `uv` as package manager.
- Use `uv sync --all-groups` command for installing all dependencies of the project.
- Use `uv add dependency` to add a dependency in the project, this will automatically update the pyproject.toml and the environment.
- Don't use `uv pip` interface.

## Project coding standards
- Use python sintax and bultins from python 3.11
- Pefer a pythonic way of doing stuff. Use list comprehension always possible
- Use **uv** as the package manager for installing dependencies. Install new
  packages with `uv add <dependency>` and avoid committing `requirements.txt`
  files.

## PR instructions
The PR should have this sections:
```pr_example.md
h### Summary 
A brief summary of the changes made
### Changes Made
A more detailed descriptions of the changes made
```
